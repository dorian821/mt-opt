#data point range for parcelized categorization
def sigma(series,n_parcels=20):
  sigma = (series.max() - series.min())/(2*n_parcels)
  return sigma

#angle of movement
def theta(data): #data is slice beginning with size of period, perhaps better to structure process differently to calculate theta for many periods  simultaneously
  theta = np.max(abs(data['high'].max()-data.ix[0]['open']),(abs(data['low'].min()-data.ix[0]['open'])))/len(data)
  return theta

#directionality
def phi(data):
  if abs(data['high'].max()-data.ix[0]['open']) > abs(data['low'].min()-data.ix[0]['open']):  
    phi = abs(data['high'].max()-data.ix[0]['open'])/abs(data['low'].min()-data.ix[0]['open'])
  elif abs(data['high'].max()-data.ix[0]['open']) < abs(data['low'].min()-data.ix[0]['open']):
    phi = -1*(abs(data['low'].min()-data.ix[0]['open'])/abs(data['high'].max()-data.ix[0]['open']))
  else:
    phi = 0
  return phi
  
#volatility -- can measure number of swings (alpha) or violence of swings (beta) -- Requires data length of 2-3+
def mu(data):
  high_swings: 2-3 day linear fit of high values count # of positive/negative switches
  low_swings: " "
  beta = max(abs(high_swings.max()),abs(low_swings.min())
  alpha_mu = average of the two?
  return alpha, beta

#indication prep process
indication_dict = {}
for indication in data_calcs.columns:
  indication_dict[indication][0] = data[indication].dtype
  if indication_dict[indication].str.contains(float):
    indication_dict[indication][1] = sigma(data[indication],n_parcels=20)
  else:
    indication_dict[indication][1] = 0
  
#estimate # of possible combinations to be tested

#need to order combination process
  #how?
    #1) indexing: could codify each combination, assign a number and then cycle through the range containing all numbers
    #2) elimination: could run all combinations with a 'base' indication and then when finished proceed to the next 'base' indication having removed the prior from the pool of indications
    
  
    
  
