
#data must be filtered to contain only trades that were entered
#data['Exit_Percentage'] = actual exit percentage (over d2op) not to be confused with Calc_Exit_Percentage
exit_col = date of exit
credit_col_name = e.g. 'Calc_Target_Exit_PnL'
D20Cl% needs to be included in the tnpsummary
def event_logger(data,market_dates): #rowwise dataframe for each acct change remember Tx# is the index!!
entries_date: pd.Series((lambda x: market_dates.ix[market_dates.loc[x].getloc() + 1] for x in data['Trade_Date']),index=data.index,name='Entry_Date')
debits = pd.Series(acct*(data['D2Op']*data['Buy_Target_Percentage']),index=data.index,name='Debits')
#debit = pd.concat([entries_date,debits],axis=1)
exits_calc_date: pd.Series(((lambda x: market_dates.ix[market_dates.loc[data.ix[x]['Trade_Date']].getloc() + data.ix[x]['Calc_Exit_Day']]) for x in data.index),index=data.index,name='Calc_Exit_Date')
calc_credits: pd.Series(((acct*(data['Exit_Percentage']-data[Buy_Target_Percentage']+1)),index=data.index,name='Calc_Target_Exit_PnL')
#calc_cred = pd.concat([exits_calc_date,calc_credits],axis=1)
exits_20_date: pd.Series(((lambda x: market_dates.ix[market_dates.loc[data.ix[x]['Trade_Date']].getloc() + data.ix[x]['20_Exit_Day']]) for x in data.index),index=data.index,name='20_Exit_Date')
#20_credits: pd.Series((np.where(data['Exit_20%_Percentage'],acct*1.2,acct*(D20Cl%-data[Buy_Target_Percentage']+1),index=data.index,name='20%_Exit_PnL')
20calc_cred = pd.concat([exits_20_date,20_credits],axis=1)
exits_50_date: pd.Series(((lambda x: market_dates.ix[market_dates.loc[data.ix[x]['Trade_Date']].getloc() + data.ix[x]['50_Exit_Day']]) for x in data.index),index=data.index,name='50_Exit_Date')
#50_credits: pd.Series((np.where(data['Exit_50%_Percentage'],acct*1.5,acct*(D20Cl%-data[Buy_Target_Percentage']+1),index=data.index,name='50%_Exit_PnL')
50calc_cred = pd.concat([exits_50_date,50_credits],axis=1)
exits_75_date: pd.Series(((lambda x: market_dates.ix[market_dates.loc[data.ix[x]['Trade_Date']].getloc() + data.ix[x]['75_Exit_Day']]) for x in data.index),index=data.index,name='75_Exit_Date')
#75_credits: pd.Series((np.where(data['Exit_75%_Percentage'],acct*1.75,acct*(D20Cl%-data[Buy_Target_Percentage']+1),index=data.index,name='75%_Exit_PnL')
75calc_cred = pd.concat([exits_75_date,75_credits],axis=1)
exits_100_date: pd.Series(((lambda x: market_dates.ix[market_dates.loc[data.ix[x]['Trade_Date']].getloc() + data.ix[x]['100_Exit_Day']]) for x in data.index),index=data.index,name='100_Exit_Date')
#100_credits: pd.Series((np.where(data['Exit_100%_Percentage'],acct*2,acct*(D20Cl%-data[Buy_Target_Percentage']+1),index=data.index,name='100%_Exit_PnL')
eventlog.index.rename('Tranx_#')
eventlog = pd.concat([entries_date,debits,exits_calc_date,calc_credits,exits_20_date,20_credits,exits_50_date,50_credits,exits_75_date,75_credits,exits_100_date,100_credits],axis=1)
return eventlog

tnpsummary = pd.concat([tnpsummary,eventlog])

exit_col= exit_target(e.g. calc,20,50,75,100)
book_columns = ['Mgmt_Policy', 'Cash_Balance', 'At_Risk_Balance', 'Daily_Profit/Loss', 'Daily_ROI', 'Debit', 'Credit']

opt_criteria_column_dict = {'symbs':'Stock_Symbol','stx':'Strike','opt_type':'Option','sort':'Sort','form':'Form_#','win_%':'Win%','profit_%':'Calc_Profit%','d2_invst_min':'D2_Investible_Volume'}
opt_criteria = [symbs,stx,opt_type,sort,form,win_%,profit_%] #Need to add exp_frame=None, at_risk-trade=None,trade_duration=None (trade duration variable based upon sell target)
def names(thing):
return [name for name,ref in globals().iteritems() if ref is thing]

def bookkeeping(eventlog,start,end,exit_date_col,exit_col,acct,symbs=None,stx=None,exp_frame=None,opt_type=None,sort=None,form=None,at_risk-trade=None,trade_duration=None,win_%=None,profit_%=None,d2_invst_min=None):
#select subset#
eventlog.set_index('Entry_Date',drop=False)
eventlog = eventlog[start:end]
eventlog.set_index('Tranx_#')
for crit in opt_criteria:
  if crit is not None:
    eventlog = eventlog[eventlog[opt_criteria_column_dict[crit]].isin(crit)]
  if crit == d2_invst:
    eventlog = eventlog[eventlog[opt_criteria_column_dict[crit]] >= crit]

#Calculate Books#
books = pd.DataFrame(index=pd.Series(eventlog['Entry_Date',exit_col].unique(),name='Date'),columns=book_columns)
books.at[start,'Cash_Balance'] = acct
for d in eventlog['entries_date'].unique():
books.at[d,'Debit'] = eventlog[['Debits']][eventlog['Entry_Date'] == d].sum()
for d in eventlog[exit_date_col].unique():
books.at[d,'Credit'] = eventlog[[exit_col]][eventlog[exit_date_col] == d].sum()
for d in books.index:
books.at[d,'Daily_Profit/Loss'] = books['Credit']-books['Debit']
days_cum_debit = eventlog['Debits'][eventlog['entries_date'] <= d].sum()
days_cum_closures = eventlog['Debits'][eventlog[exit_date_col] <= d].sum()
books.at[d,'At_Risk_Balance'] = days_cum_debit - days_cum_closures
books.at[d,'Daily_ROI'] = eventlog[exit_col][eventlog[exit_date_col] <= d].sum()/eventlog['Debits'][eventlog['entries_date'] <= d].sum() 
x = books.index.get_loc(d) - 1
books.at[d,'Cash_Balance'] = books.ix[x]['Cash_Balance'] + books.ix[d]['Debit'] + books.ix[d]['Credit']
return books


1.  Date or date range; ==:)O
2. stock(s); ==:)O
3. option position; ==:)O
4. option expiration dates; ==:)O ! Need to organize process tree for incorporating additional timeframes
5. type of option i.e. put or call; ==:)O
6. sort  and form number;  ==:)O
7. “At Risk Amt”/ trade; ==:)O ! Need to define, because currently we are operating on a nominal 10k
8.  Time in the trade; ==:)O !
9. win percentage given the selected date range i.e. 80%+ or 90%+;  ==:)O
10.  Profit percentage, either calculated by program or selected i.e. 20% or 100%+.  ==:)O


